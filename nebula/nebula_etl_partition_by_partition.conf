nebula: {
  space: "bitcoin"
  # ... other settings ...
}

tags: [
  {
    name: block
    # ...
    sentence: """
      SELECT hash AS vid, number AS block_number,
             formatDateTime(timestamp, '%Y-%m-%d %H:%M:%S') AS block_timestamp,
             previous_block_hash
      FROM blocks
      WHERE toYYYYMM(timestamp) = '${YM}'
      FINAL
    """
    fields: [block_number, block_timestamp, previous_block_hash]
    nebula.fields: [block_number, block_timestamp, previous_block_hash]
    vertex: { field: vid }
  },
  {
    name: transaction
    # ...
    sentence: """
      SELECT hash AS vid, is_coinbase, block_number,
             formatDateTime(block_timestamp, '%Y-%m-%d %H:%M:%S') AS block_timestamp
      FROM transactions
      WHERE toYYYYMM(block_timestamp)='${YM}'
      FINAL
    """
    fields: [is_coinbase, block_number, block_timestamp]
    nebula.fields: [is_coinbase, block_number, block_timestamp]
    vertex: { field: vid }
  },
  {
    name: output
    # ...
    sentence: """
      SELECT concat(transaction_hash, ':', toString(output_index)) AS vid,
             transaction_hash, toInt32(output_index) AS output_index,
             type AS output_type, value AS output_value
      FROM outputs
      WHERE toYYYYMM(block_timestamp)='${YM}'
      FINAL
    """
    fields: [transaction_hash, output_index, output_type, output_value]
    nebula.fields: [transaction_hash, output_index, output_type, output_value]
    vertex: { field: vid }
  },
  {
    name: address
    # ...
    sentence: """
      SELECT DISTINCT addr AS vid, addr AS address
      FROM (
        SELECT arrayJoin(addresses) AS addr
        FROM outputs
        WHERE toYYYYMM(block_timestamp)='${YM}'
        FINAL HAVING length(addr) > 0
      )
    """
    fields: [address]
    nebula.fields: [address]
    vertex: { field: vid }
  }
]

edges: [
  {
    name: belongs_to
    sentence: """
      SELECT hash AS src, block_hash AS dst
      FROM transactions
      WHERE toYYYYMM(block_timestamp)='${YM}'
      FINAL
    """
    fields: []
    nebula.fields: []
    source: { field: src }
    target: { field: dst }
  },
  {
    name: lock_to
    sentence: """
      SELECT transaction_hash AS src,
             concat(transaction_hash, ':', toString(output_index)) AS dst,
             toInt32(output_index) AS output_index
      FROM outputs
      WHERE toYYYYMM(block_timestamp)='${YM}'
      FINAL
    """
    fields: [output_index]           # include only if you keep this edge prop
    nebula.fields: [output_index]
    source: { field: src }
    target: { field: dst }
  },
  {
    name: pay_to
    sentence: """
      SELECT concat(transaction_hash, ':', toString(output_index)) AS src,
             arrayJoin(addresses) AS dst
      FROM outputs
      WHERE toYYYYMM(block_timestamp)='${YM}'
      FINAL HAVING length(dst) > 0
    """
    fields: []
    nebula.fields: []
    source: { field: src }
    target: { field: dst }
  },
  {
    name: spent_by
    sentence: """
      SELECT concat(transaction_hash, ':', toString(output_index)) AS src,
             spent_transaction_hash AS dst,
             toInt32(spent_input_index) AS spent_input_index
      FROM outputs
      WHERE toYYYYMM(block_timestamp)='${YM}'
        AND revision > 0
      FINAL
    """
    fields: [spent_input_index]
    nebula.fields: [spent_input_index]
    source: { field: src }
    target: { field: dst }
  },
  {
    name: coinbase
    sentence: """
      SELECT block_hash AS src, hash AS dst
      FROM transactions
      WHERE toYYYYMM(block_timestamp)='${YM}' AND is_coinbase = 1
      FINAL
    """
    fields: []
    nebula.fields: []
    source: { field: src }
    target: { field: dst }
  },
  {
    name: chain_to
    sentence: """
      SELECT hash AS src, previous_block_hash AS dst
      FROM blocks
      WHERE toYYYYMM(timestamp)='${YM}'
        AND previous_block_hash IS NOT NULL
        AND previous_block_hash != ''
      FINAL
    """
    fields: []
    nebula.fields: []
    source: { field: src }
    target: { field: dst }
  }
]
